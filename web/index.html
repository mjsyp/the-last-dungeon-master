<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Last Dungeon Master (DM-VA)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .chat-message {
            display: flex;
            flex-direction: column;
            max-width: 75%;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .chat-message.user {
            align-self: flex-end;
        }
        
        .chat-message.system {
            align-self: flex-start;
        }
        
        .message-bubble {
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .chat-message.user .message-bubble {
            background: #4CAF50;
            color: #fff;
            border-bottom-right-radius: 4px;
        }
        
        .chat-message.system .message-bubble {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            border-bottom-left-radius: 4px;
        }
        
        .message-meta {
            font-size: 0.75em;
            opacity: 0.7;
            margin-top: 4px;
            padding: 0 4px;
        }
        
        .chat-message.user .message-meta {
            text-align: right;
        }
        
        .chat-input-area {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .listen-indicator {
            display: none;
            padding: 8px 12px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 20px;
            font-size: 0.9em;
            animation: pulse-red 1.5s infinite;
        }
        
        .listen-indicator.active {
            display: block;
        }
        
        @keyframes pulse-red {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .chat-input-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .chat-input {
            width: 100%;
            min-height: 50px;
            max-height: 150px;
            padding: 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-family: inherit;
            font-size: 1em;
            resize: none;
            overflow-y: auto;
        }
        
        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .chat-input:focus {
            outline: none;
            border-color: #4CAF50;
        }
        
        .chat-send-btn {
            padding: 12px 24px;
            background: #4CAF50;
            border: none;
            border-radius: 20px;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
            height: 50px;
            white-space: nowrap;
        }
        
        .chat-send-btn:hover {
            background: #45a049;
        }
        
        .chat-send-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
        }
        
        .typing-indicator {
            display: none;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 18px;
            border-bottom-left-radius: 4px;
            max-width: 75px;
            align-self: flex-start;
        }
        
        .typing-indicator.active {
            display: flex;
            gap: 4px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.6;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            margin-bottom: 0;
        }
        
        .panel.collapsible {
            position: relative;
        }
        
        .panel.collapsed {
            padding: 10px 20px;
        }
        
        .panel.collapsed .panel-content {
            display: none;
        }
        
        .panel h2 {
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            cursor: pointer;
            user-select: none;
        }
        
        .chat-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 0.7em;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
            user-select: none;
        }
        
        .checkbox-label:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }
        
        .checkbox-label input[type="checkbox"]:checked + span {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .checkbox-label.active {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
        }
        
        .panel.collapsed h2 {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .collapse-toggle {
            font-size: 0.8em;
            opacity: 0.7;
            transition: transform 0.3s ease;
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .collapse-toggle:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .panel.collapsed .collapse-toggle {
            transform: rotate(180deg);
        }
        
        .panel-content {
            transition: opacity 0.3s ease;
        }
        
        .status-panel {
            grid-column: 1 / -1;
            margin-bottom: 20px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-label {
            font-weight: bold;
            opacity: 0.8;
        }
        
        .status-value {
            font-family: 'Courier New', monospace;
        }
        
        .mode-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .mode-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .mode-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .mode-card:hover::before {
            left: 100%;
        }
        
        .mode-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .mode-card.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        .mode-card.active::after {
            content: '‚óè';
            position: absolute;
            top: 10px;
            right: 10px;
            color: #4CAF50;
            font-size: 1.2em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }
        
        .mode-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
        }
        
        .mode-description {
            font-size: 0.85em;
            opacity: 0.9;
            line-height: 1.4;
        }
        
        .input-area {
            margin-top: 15px;
        }
        
        .input-area h3 {
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
        }
        
        textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        button {
            padding: 12px 24px;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
        }
        
        .output-area {
            margin-top: 15px;
        }
        
        .output {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 15px;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        .entity-list {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .entity-list h4 {
            margin-bottom: 10px;
            font-size: 1em;
            opacity: 0.9;
        }
        
        .entity-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 5px;
            border-left: 3px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .entity-item:hover {
            background: rgba(0, 0, 0, 0.3);
            border-left-color: #4CAF50;
        }
        
        .entity-item.empty {
            opacity: 0.6;
            font-style: italic;
            cursor: default;
        }
        
        .entity-name {
            font-weight: bold;
        }
        
        .entity-meta {
            font-size: 0.85em;
            opacity: 0.8;
            margin-top: 4px;
        }
        
        .loading {
            opacity: 0.6;
            font-style: italic;
        }
        
        .error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .success {
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .info-panel {
            grid-column: 1 / -1;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .mode-selector {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé≤ The Last Dungeon Master</h1>
            <p class="subtitle">Voice-Driven Dungeon Master Virtual Assistant</p>
        </header>
        
        <div class="panel status-panel collapsible" id="status-panel">
            <h2 onclick="togglePanel('status-panel')">
                <span>Session Status</span>
                <span class="collapse-toggle">‚ñº</span>
            </h2>
            <div class="panel-content" id="status-content">
                <div class="status-item">
                    <span class="status-label">Mode:</span>
                    <span class="status-value" id="current-mode">main_menu_mode</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Universe:</span>
                    <span class="status-value" id="universe-id">None</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Campaign:</span>
                    <span class="status-value" id="campaign-id">None</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Party:</span>
                    <span class="status-value" id="party-id">None</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Turn:</span>
                    <span class="status-value" id="turn-index">0</span>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="panel collapsible" id="mode-panel">
                <h2 onclick="togglePanel('mode-panel')">
                    <span>Mode Selection</span>
                    <span class="collapse-toggle">‚ñº</span>
                </h2>
                <div class="panel-content">
                    <div class="mode-selector" id="mode-selector">
                        <!-- Modes will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>
                    <span>Chat</span>
                    <div class="chat-controls">
                        <label class="checkbox-label">
                            <input type="checkbox" id="listen-checkbox">
                            <span>üé§ Listen</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="speak-checkbox" checked>
                            <span>üîä Speak</span>
                        </label>
                    </div>
                </h2>
                <div class="chat-container">
                    <div class="chat-history" id="chat-history">
                        <div class="chat-message system">
                            <div class="message-bubble">
                                Welcome to DM-VA! Select a mode and start interacting.
                            </div>
                            <div class="message-meta">System</div>
                        </div>
                    </div>
                    <div class="typing-indicator" id="typing-indicator">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                    <div class="chat-input-area">
                        <div class="chat-input-wrapper">
                            <div class="listen-indicator" id="listen-indicator">üé§ Listening...</div>
                            <textarea 
                                id="chat-input" 
                                class="chat-input" 
                                placeholder="Type your message here... (Ctrl+Enter to send)"
                                rows="1"
                            ></textarea>
                        </div>
                        <button id="chat-send-btn" class="chat-send-btn" onclick="handleChatSubmit()">Send</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel info-panel" id="entity-panel" style="display: none;">
            <h2>World Entities</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div class="entity-list">
                    <h4>Universes</h4>
                    <div id="universes-list">Loading...</div>
                </div>
                <div class="entity-list">
                    <h4>Campaigns</h4>
                    <div id="campaigns-list">Loading...</div>
                </div>
                <div class="entity-list">
                    <h4>Characters</h4>
                    <div id="characters-list">Loading...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE = '';
        let currentMode = null;
        let chatHistory = [];
        let isListening = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let audioContext = null;
        
        const MODE_INFO = {
            'main_menu_mode': {
                name: 'Main Menu',
                description: 'Manage universes, campaigns, and parties. Select your active world context.'
            },
            'world_architect_mode': {
                name: 'World Architect',
                description: 'Generate or import new universes and campaigns. Create rich, interconnected worlds.'
            },
            'dm_story_mode': {
                name: 'DM Story',
                description: 'Live session play. The DM narrates the world and responds to player actions.'
            },
            'rules_explanation_mode': {
                name: 'Rules Explanation',
                description: 'Ask questions about game rules and mechanics. Get clear explanations with examples.'
            },
            'tutorial_mode': {
                name: 'Tutorial',
                description: 'Guided walkthroughs to learn the system and game mechanics step-by-step.'
            },
            'world_edit_mode': {
                name: 'World Edit',
                description: 'Propose changes to the world. The system checks for conflicts and helps resolve them.'
            }
        };
        
        // Initialize mode selector
        function initModeSelector() {
            const selector = document.getElementById('mode-selector');
            selector.innerHTML = '';
            
            Object.entries(MODE_INFO).forEach(([mode, info]) => {
                const card = document.createElement('div');
                card.className = 'mode-card';
                card.dataset.mode = mode;
                card.innerHTML = `
                    <div class="mode-name">${info.name}</div>
                    <div class="mode-description">${info.description}</div>
                `;
                card.addEventListener('click', () => switchMode(mode));
                selector.appendChild(card);
            });
        }
        
        // Load initial state
        async function loadState() {
            try {
                const response = await fetch(`${API_BASE}/api/state`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const state = await response.json();
                currentMode = state.current_mode;
                updateUI(state);
                loadEntities();
            } catch (error) {
                console.error('Error loading state:', error);
                // Set default values if state fails to load
                document.getElementById('current-mode').textContent = 'main_menu_mode';
                document.getElementById('universe-id').textContent = 'None';
                document.getElementById('campaign-id').textContent = 'None';
                document.getElementById('party-id').textContent = 'None';
                document.getElementById('turn-index').textContent = '0';
                showError('Failed to load session state');
            }
        }
        
        function updateUI(state) {
            document.getElementById('current-mode').textContent = state.current_mode || 'None';
            document.getElementById('universe-id').textContent = state.active_universe_id || 'None';
            document.getElementById('campaign-id').textContent = state.active_campaign_id || 'None';
            document.getElementById('party-id').textContent = state.active_party_id || 'None';
            document.getElementById('turn-index').textContent = state.turn_index || 0;
            
            // Update active mode card using the helper function
            updateModeIndicator(state.current_mode);
        }
        
        // Load entities (universes, campaigns, characters)
        async function loadEntities() {
            try {
                // Load universes
                const universesRes = await fetch(`${API_BASE}/api/universes`);
                const universes = await universesRes.json();
                displayEntities('universes-list', universes, 'name', 'description');
                
                // Load campaigns
                const campaignsRes = await fetch(`${API_BASE}/api/campaigns`);
                const campaigns = await campaignsRes.json();
                displayEntities('campaigns-list', campaigns, 'name', 'genre');
                
                // Load characters
                const charactersRes = await fetch(`${API_BASE}/api/characters`);
                const characters = await charactersRes.json();
                displayEntities('characters-list', characters, 'name', 'role');
                
                // Show entity panel if we have entities or in relevant modes
                const relevantModes = ['main_menu_mode', 'world_architect_mode', 'dm_story_mode', 'world_edit_mode'];
                if (relevantModes.includes(currentMode) && (universes.length > 0 || campaigns.length > 0 || characters.length > 0)) {
                    document.getElementById('entity-panel').style.display = 'block';
                } else {
                    document.getElementById('entity-panel').style.display = 'none';
                }
            } catch (error) {
                console.error('Error loading entities:', error);
            }
        }
        
        function displayEntities(containerId, entities, nameField, metaField) {
            const container = document.getElementById(containerId);
            if (entities.length === 0) {
                container.innerHTML = '<div class="entity-item empty">No items yet</div>';
                return;
            }
            
            container.innerHTML = entities.map(entity => `
                <div class="entity-item">
                    <div class="entity-name">${entity[nameField] || 'Unnamed'}</div>
                    <div class="entity-meta">${entity[metaField] || ''}</div>
                </div>
            `).join('');
        }
        
        // Mode switching
        async function switchMode(mode) {
            try {
                const response = await fetch(`${API_BASE}/api/mode/switch`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode })
                });
                const result = await response.json();
                if (result.status === 'success') {
                    currentMode = result.mode;
                    // Update UI immediately
                    updateModeIndicator(result.mode);
                    // Then refresh full state
                    await loadState();
                    showSuccess(`Switched to ${MODE_INFO[mode].name}`);
                }
            } catch (error) {
                console.error('Error switching mode:', error);
                showError('Failed to switch mode');
            }
        }
        
        // Update mode indicator immediately
        function updateModeIndicator(mode) {
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.mode === mode) {
                    card.classList.add('active');
                }
            });
            // Also update the status display
            if (document.getElementById('current-mode')) {
                document.getElementById('current-mode').textContent = mode || 'None';
            }
        }
        
        // Add message to chat history
        function addChatMessage(text, sender, metadata = {}) {
            const chatHistoryEl = document.getElementById('chat-history');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.textContent = text;
            messageDiv.appendChild(bubble);
            
            const meta = document.createElement('div');
            meta.className = 'message-meta';
            meta.textContent = metadata.label || sender;
            messageDiv.appendChild(meta);
            
            chatHistoryEl.appendChild(messageDiv);
            scrollChatToBottom();
            
            // Store in history
            chatHistory.push({ text, sender, timestamp: new Date(), metadata });
        }
        
        // Scroll chat to bottom
        function scrollChatToBottom() {
            const chatHistoryEl = document.getElementById('chat-history');
            chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
        }
        
        // Show/hide typing indicator
        function showTypingIndicator(show = true) {
            const indicator = document.getElementById('typing-indicator');
            if (show) {
                indicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
            }
            scrollChatToBottom();
        }
        
        // Handle chat submission (text input)
        async function handleChatSubmit() {
            const input = document.getElementById('chat-input').value.trim();
            if (!input) return;
            
            // Add user message to chat
            addChatMessage(input, 'user', { label: 'You' });
            
            // Process the input
            await processUserInput(input);
        }
        
        // Process user input (from text or STT)
        async function processUserInput(inputText) {
            const sendBtn = document.getElementById('chat-send-btn');
            const inputEl = document.getElementById('chat-input');
            
            sendBtn.disabled = true;
            showTypingIndicator(true);
            
            try {
                let endpoint = '';
                let body = {};
                
                // Route to appropriate endpoint based on mode
                switch (currentMode) {
                    case 'dm_story_mode':
                        endpoint = '/api/dm-story/input';
                        body = { player_utterance: inputText };
                        break;
                    case 'world_architect_mode':
                        endpoint = '/api/world-architect/generate';
                        body = { requirements: inputText };
                        break;
                    case 'rules_explanation_mode':
                        endpoint = '/api/rules/explain';
                        body = { question: inputText };
                        break;
                    case 'world_edit_mode':
                        endpoint = '/api/world-edit/propose';
                        body = { proposed_change: inputText, player_id: 'user1' };
                        break;
                    default:
                        endpoint = '/api/dm-story/input';
                        body = { player_utterance: inputText };
                }
                
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                const result = await response.json();
                
                // Hide typing indicator
                showTypingIndicator(false);
                
                // Format and add response
                let responseText = '';
                if (result.narration) {
                    responseText = result.narration;
                } else if (result.explanation) {
                    responseText = result.explanation;
                } else if (result.error) {
                    responseText = `Error: ${result.error}`;
                } else {
                    responseText = JSON.stringify(result, null, 2);
                }
                
                // Add system response to chat
                const modeLabel = MODE_INFO[currentMode]?.name || 'System';
                addChatMessage(responseText, 'system', { label: modeLabel });
                
                // Play TTS if Speak is enabled
                if (speakCheckbox.checked && responseText) {
                    // Show TTS indicator in chat
                    addChatMessage('üîä Speaking...', 'system', { label: 'TTS' });
                    await playTTS(responseText);
                }
                
                // Show additional info if present
                if (result.log_updates) {
                    const updatesText = `[State Updates]\n${JSON.stringify(result.log_updates, null, 2)}`;
                    addChatMessage(updatesText, 'system', { label: 'System' });
                }
                
                if (result.world_edit) {
                    const editText = `[World Edit]\n${JSON.stringify(result.world_edit, null, 2)}`;
                    addChatMessage(editText, 'system', { label: 'System' });
                }
                
                await loadState();
                await loadEntities();
                
            } catch (error) {
                console.error('Error processing input:', error);
                showTypingIndicator(false);
                addChatMessage(`Error: ${error.message}`, 'system', { label: 'Error' });
            } finally {
                sendBtn.disabled = false;
                inputEl.value = '';
                inputEl.style.height = 'auto';
                inputEl.focus();
            }
        }
        
        // Start listening with microphone
        async function startListening() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Create MediaRecorder
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await processAudioInput(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };
                
                // Start recording
                mediaRecorder.start();
                isListening = true;
                listenIndicator.classList.add('active');
                updateCheckboxLabels();
                
                // Auto-stop after 5 seconds of silence or manual stop
                setTimeout(() => {
                    if (isListening && mediaRecorder.state === 'recording') {
                        stopListening();
                    }
                }, 5000);
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                showError('Failed to access microphone. Please check permissions.');
                listenCheckbox.checked = false;
                updateCheckboxLabels();
            }
        }
        
        // Stop listening
        function stopListening() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isListening = false;
            listenIndicator.classList.remove('active');
            updateCheckboxLabels();
        }
        
        // Process audio input through STT
        async function processAudioInput(audioBlob) {
            try {
                // Show processing message
                addChatMessage('Processing audio...', 'system', { label: 'System' });
                
                // Convert to format Deepgram can use
                const formData = new FormData();
                formData.append('audio', audioBlob, 'audio.webm');
                
                // Send to STT endpoint
                const response = await fetch(`${API_BASE}/api/stt/transcribe`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.transcript) {
                    // Add transcript to chat
                    addChatMessage(result.transcript, 'user', { label: 'You (Voice)' });
                    
                    // Process as if it was typed
                    await processUserInput(result.transcript);
                } else {
                    addChatMessage('Could not transcribe audio. Please try again.', 'system', { label: 'Error' });
                }
                
            } catch (error) {
                console.error('Error processing audio:', error);
                addChatMessage(`Error processing audio: ${error.message}`, 'system', { label: 'Error' });
            }
        }
        
        // Play TTS audio
        async function playTTS(text) {
            try {
                // Request TTS from server
                const response = await fetch(`${API_BASE}/api/tts/synthesize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Play audio
                const audio = new Audio(audioUrl);
                await audio.play();
                
                // Clean up
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                };
                
            } catch (error) {
                console.error('Error playing TTS:', error);
                // Don't show error to user, just log it
            }
        }
        
        // Listen/Speak checkbox handlers
        const listenCheckbox = document.getElementById('listen-checkbox');
        const speakCheckbox = document.getElementById('speak-checkbox');
        const listenIndicator = document.getElementById('listen-indicator');
        
        listenCheckbox.addEventListener('change', async (e) => {
            if (e.target.checked) {
                await startListening();
            } else {
                stopListening();
            }
        });
        
        speakCheckbox.addEventListener('change', (e) => {
            // Just update the state, TTS will be used when processing responses
            updateCheckboxLabels();
        });
        
        function updateCheckboxLabels() {
            const listenLabel = listenCheckbox.closest('.checkbox-label');
            const speakLabel = speakCheckbox.closest('.checkbox-label');
            
            if (listenCheckbox.checked) {
                listenLabel.classList.add('active');
            } else {
                listenLabel.classList.remove('active');
            }
            
            if (speakCheckbox.checked) {
                speakLabel.classList.add('active');
            } else {
                speakLabel.classList.remove('active');
            }
        }
        
        // Auto-resize textarea
        const chatInput = document.getElementById('chat-input');
        chatInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 150) + 'px';
        });
        
        // Enter key to submit (Ctrl+Enter or just Enter)
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                handleChatSubmit();
            } else if (e.key === 'Enter' && !e.shiftKey) {
                // Allow Enter to submit, Shift+Enter for new line
                e.preventDefault();
                handleChatSubmit();
            }
        });
        
        function showError(message) {
            addChatMessage(message, 'system', { label: 'Error' });
        }
        
        function showSuccess(message) {
            addChatMessage(message, 'system', { label: 'Success' });
        }
        
        // Initialize
        initModeSelector();
        // Load state immediately and set up intervals
        loadState().catch(err => {
            console.error('Initial state load failed:', err);
            // Set defaults
            document.getElementById('current-mode').textContent = 'main_menu_mode';
        });
        setInterval(loadState, 5000); // Refresh state every 5 seconds
        setInterval(loadEntities, 10000); // Refresh entities every 10 seconds
        
        // Panel collapse/expand functionality
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            panel.classList.toggle('collapsed');
            
            // Save state to localStorage
            const isCollapsed = panel.classList.contains('collapsed');
            localStorage.setItem(`panel_${panelId}_collapsed`, isCollapsed);
        }
        
        // Restore panel states from localStorage
        function restorePanelStates() {
            const panels = ['status-panel', 'mode-panel'];
            panels.forEach(panelId => {
                const isCollapsed = localStorage.getItem(`panel_${panelId}_collapsed`) === 'true';
                const panel = document.getElementById(panelId);
                if (panel && isCollapsed) {
                    panel.classList.add('collapsed');
                }
            });
        }
        
        // Listen/Speak checkbox handlers (must be defined before initialization)
        const listenCheckbox = document.getElementById('listen-checkbox');
        const speakCheckbox = document.getElementById('speak-checkbox');
        const listenIndicator = document.getElementById('listen-indicator');
        
        listenCheckbox.addEventListener('change', async (e) => {
            if (e.target.checked) {
                await startListening();
            } else {
                stopListening();
            }
        });
        
        speakCheckbox.addEventListener('change', (e) => {
            // Just update the state, TTS will be used when processing responses
            updateCheckboxLabels();
        });
        
        function updateCheckboxLabels() {
            const listenLabel = listenCheckbox.closest('.checkbox-label');
            const speakLabel = speakCheckbox.closest('.checkbox-label');
            
            if (listenCheckbox.checked) {
                listenLabel.classList.add('active');
            } else {
                listenLabel.classList.remove('active');
            }
            
            if (speakCheckbox.checked) {
                speakLabel.classList.add('active');
            } else {
                speakLabel.classList.remove('active');
            }
        }
        
        // Focus chat input on load
        document.getElementById('chat-input').focus();
        
        // Restore panel states
        restorePanelStates();
        
        // Initialize checkbox labels
        updateCheckboxLabels();
    </script>
</body>
</html>
